{{ define "main" }}

    <main aria-role="main">
      <header class="homepage-header">
      </header>
      <div class="doi">
        <!-- Note that the content for index.html, as a sort of list page, will pull from content/_index.md -->
        {{ with .Site.Data.doi }}
          {{ with .top }}
            {{ partial "single/top.html" . }}
          {{ end }}
          
          {{ partial "doi/graphics_what.html" . }}

          {{ with .statistics }}
            {{ partial "doi/how_many.html" . }}
          {{ end }}
          
          
          {{ partial "doi/graphics_why.html" . }}

          {{ with .what }}
            {{ partial "doi/what.html" . }}
          {{ end }}
          
          {{ with .benefits }}
            {{ partial "doi/benefits.html" . }}
          {{ end }}

          
          {{ partial "doi/growth_graph.html" . }}

          {{ with .infos }}
            {{ partial "single/infos.html" . }}
          {{ end }}

          {{ with .how_get }}
            {{ partial "doi/how_get.html" . }}
          {{ end }}

          
          {{ partial "doi/hits_graph.html" . }}

          {{ with .standards }}
            {{ partial "doi/standards.html" . }}
          {{ end }}
          
          {{ partial "doi/world_map.html" . }}
          
          {{ with .visualisations }}
            {{ partial "doi/visualisations.html" . }}
          {{ end }}
          
        {{ end }}

        
        {{ partial "socials-side.html" . }}
      </div>
    </main>
    <script>
      /* for animating svg */
    const observer = new IntersectionObserver(entries => {
        entries.forEach(entry => {
          const square = entry.target.querySelector('.path.line');
          const circles = entry.target.querySelectorAll('.path.circle');
      
          if (entry.isIntersecting) {
            square.classList.add('line-animation');
            circles.forEach(( thing) => thing.classList.add('circle-animation'));
            return; // if we added the class, exit the function
          }
      
          // We're not intersecting, so remove the class!
          square.classList.remove('line-animation');
          circles.forEach(( thing) => thing.classList.remove('circle-animation'));
        });
      });
      
      observer.observe(document.querySelector('.circle-line'));
    
    
    
    
      const observerlower = new IntersectionObserver(entries => {
        entries.forEach(entry => {
          const square = entry.target.querySelector('.path.line');
          const circles = entry.target.querySelectorAll('.path.circle');
      
          if (entry.isIntersecting) {
            square.classList.add('line-animation');
            circles.forEach(( thing) => thing.classList.add('circle-animation'));
            return; // if we added the class, exit the function
          }
      
          // We're not intersecting, so remove the class!
          square.classList.remove('line-animation');
          circles.forEach(( thing) => thing.classList.remove('circle-animation'));
        });
      });
      
      observerlower.observe(document.querySelector('.circle-line-lower'));
      </script>


      <script>

        const STATS_REFRESH_INTERVAL = 1000 * 60 * 60; //one hour in ms
        const RESOLUTIONS_CLOCK_UPDATE_INTERVAL = 500; //half a second in ms

        let resolutionsClockIntervalId = null;

        let doiResolutions = null;
        let counts = null;
        let mapMode = "logScale";



        async function getDoiValueAsJson(doi, type) {
            let url = 'https://doi.org/api/handles/' + doi + '?type=' + type + "&auth";
            const response = await fetch(url);
            let handleRecord = await response.json();
            let handleValue = handleRecord.values[0];
            let valueJson = handleValue.data.value;
            let result = JSON.parse(valueJson);
            console.log("Fetching stats");
            return result;
        }

        async function fetchStats() {
            doiResolutions = await getDoiValueAsJson('10.1000/1000', 'DOI_RESOLUTIONS');
            counts = await getDoiValueAsJson('10.1000/1000', 'DOI_COUNTS');
            console.log("Stats loaded");
            renderResults(doiResolutions,counts);
            setTimeout(fetchStats, STATS_REFRESH_INTERVAL);
        }
        fetchStats();

        function renderResults(doiResolutions,counts) {
            renderResolutionsClock(doiResolutions);
            google.charts.load('current', { 'packages': ['corechart','line','table'] });
            google.charts.setOnLoadCallback(renderResolutionsChart(doiResolutions)); 
            google.charts.setOnLoadCallback(renderTotalHandlesChart(counts)); 
            renderResolutionsMap(doiResolutions);
        }

        function renderResolutionsMap(doiResolutions) {
          let mode = mapMode;
          let resolutionsByCountry = convertResolutionsByCountryForGoogleMap(doiResolutions.resolutionsByCountryLastMonth, mode);
          var data = google.visualization.arrayToDataTable(resolutionsByCountry);
          var options = {
              backgroundColor: 'transparent',
              colorAxis: {colors: ['white', '#5C7392']},
              legend: 'none'
          };
          var chart = new google.visualization.GeoChart(document.getElementById('world_map'));
          chart.draw(data, options);
        }
        function convertResolutionsByCountryForGoogleMap(resolutionsByCountry, mode) {
          let result = [];
          let columns = ['Country', 'Resolutions'];
          result.push(columns);
          let count = 0;
          for (let country of resolutionsByCountry) {
              let code = country.countryCode;
              let rawValue = parseInt(country.resolutions);
              let formattedValue = "" + rawValue;
              let value = Math.log(rawValue);
              let item = {
                  v: value,
                  f: formattedValue
              };
              let row = [code, item];
              result.push(row);
              count++;
          }
          return result;
        }

        function renderResolutionsClock(doiResolutions) {
            let resolutionsTotalAndRate = doiResolutions.resolutionsTotalAndRate;
            let clockElement = document.getElementById('resolutions_clock_count');
            let rateElement = document.getElementById('resolutions_clock_rate');

            let ratePerSecond = resolutionsTotalAndRate.resolutionsPerSecondLastCompleteMonth;
            let incrementPerMs = ratePerSecond / 1000;
            rateElement.textContent = ratePerSecond + "/second"

            let start = new Date(resolutionsTotalAndRate.asOfTimestamp);
            let currentCount = calculateResolutionsClock(start, incrementPerMs, resolutionsTotalAndRate.allTime);
            clockElement.textContent = getClockText(currentCount);
            clearInterval(resolutionsClockIntervalId);
            resolutionsClockIntervalId = setInterval(function() {
                let currentCount = calculateResolutionsClock(start, incrementPerMs, resolutionsTotalAndRate.allTime);
                let clockText = getClockText(currentCount);
                clockElement.textContent = clockText;
            }, RESOLUTIONS_CLOCK_UPDATE_INTERVAL);
        }

        function calculateResolutionsClock(start, incrementPerMs, initialCount) {
            let timeSinceStartMs = Date.now() - start;
            let increment = Math.round(incrementPerMs * timeSinceStartMs);
            let currentCount = initialCount + increment;
            return currentCount;
        }

        function getClockText(count) {
            let clockText = count.toLocaleString("en-US");
            return clockText;
        }  

        function renderTotalHandlesChart(counts) {
          let totalDois = convertTotalDoisDataForGoogleCharts(counts);
          var data = google.visualization.arrayToDataTable(totalDois);
          var options = {
              chartArea: {'height': '80%'},
              backgroundColor: 'transparent', 
              responsive: true,        
              height:600,
              colors: ['#5C7392'],
              title: 'Total DOIs',
              legend: { position: 'bottom' },
              trendlines: {
                  0: {
                      type: 'exponential',
                      color: '#FAB70C'
                  }
              }
          };
          
          var chart = new google.visualization.LineChart(document.getElementById('total-dois'));
          chart.draw(data, options);
        }
        function convertTotalDoisDataForGoogleCharts(monthlyCounts) {
            let result = [];
            let columns = ["Date", "Total DOIs"];
            result.push(columns);
            for (let month in monthlyCounts) {
                let value = monthlyCounts[month].doiCount;
                let row = [new Date(month), value];
                result.push(row);
            }
            return result;
        }

        function renderResolutionsChart(doiResolutions) {
            let monthlyResolutions = doiResolutions.monthlyResolutions;

            monthLabels = [];
            resolutions = [];
            both = [];
            
            var data = new google.visualization.DataTable();
            data.addColumn('date', 'date');
            data.addColumn('number', 'resolutions');

            for (var key in monthlyResolutions) {
              if (!monthlyResolutions[key].isIncompleteMonth) {
                if(key.substr(5)=='01') {
                  monthLabels.push(key.substr(0,4));
                } else {
                  monthLabels.push("");
                }
                //monthLabels.push(key);
                resolutions.push(monthlyResolutions[key].resolutions) 
                both.push([key, monthlyResolutions[key].resolutions ]) ; 
                
                //console.log('adding row');
                datestring = key + "-01";
                var dateobj = new Date(datestring);
                //console.log("datestring= " , datestring);
                data.addRow([dateobj, monthlyResolutions[key].resolutions ]);
                          
              }
            }
            //console.log(both);
            // Define the chart to be drawn.
            console.log("drawing google chart");
              
            // Set chart options
            var options = {
              hAxis: {
                format: 'Y',
                slantedText:true,
                slantedTextAngle:45
              },
              chartArea: {'height': '80%'},
              fontName:'futura-pt',
              colors: ['#5C7392'],
              title:'DOI Resolutions', 
              responsive: true,        
              height:600,
              timeline: {
                groupByRowLabel: true
              },
              legend: { position: 'bottom'},
              trendlines : { 
                0: 
                  {
                    type: 'polynomial',
                    degree: 3,
                    color: '#FAB70C'
                  }
              }	// Draw a trendline for data series 0.
            };

            // Instantiate and draw the chart.
            var chart = new google.visualization.LineChart(document.getElementById('doi-resolutions'));
            chart.draw(data, options);

            return;
        }

      </script>

      
      <script>
          
      </script>



{{ end }}